#coding:utf-8
'''
    垃圾回收
        为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间
        小整数的定义：[-5,257]这些整数对象是提前建立好的，不会被垃圾回收
                      在一个Python的程序中，所有位于这个范围内的整数使用的都是同一个对象。

        以引用计数为主，以隔代回收为辅：
        Python中有三条链表，俗称三代
            第0代，用于存放新创建的对象引用，并且默认给每个引用的数量加1
                    在一定的时间后，进行垃圾回收时，再把每个引用减去1，如果减去1后，大于0说明这个对象还有引用；
                    如果等于0，说明没有引用，此时就把为0引用的对象删除掉，然后把不为0的引用移动到第二条链表上。
            第1代，用于存放，第一条链表上清除后剩下的对象引用；在一定的时间后，再次进行如上边的垃圾回收操作；
                    为零的对象引用删除掉，不为0的移动到第三条链表上；
            第2代，同第二代一样的功能；

            经过三代链表的过滤，能有效的加快垃圾回收的速度。

            如果：
                700,创建后的对象太多了，减去销毁的后，大于700的话，此时就会触发第0代回收机制；
                10,每清理10次0代链表会清理一次1代链表，并且会顺带将0点链表也清理掉；
                10,每清理10次1代链表会清理一次2代链表，并且会顺带0/1代链表也清理掉。

        常用函数：
            1、gc.set_debug(flags)设置gc的debug日志，一般设置为gc.DEBUG_LEAK
            2、gc.collect([generation])显示进行垃圾回收，可以输入参数；
                0代表只检查第一代的对象；
                1代表检查1/2代的对象；
                2代表检查1/2/3代的对象；
            3、gc.get_threshold()获取的gc模块中自动执行垃圾回收的频率；
            4、gc.set_threshold(threshold0[,threshold 1],threshold 2)设置自动执行垃圾回收的频率；
            5、gc.get_count()获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表

        必须要import gc模块，并且is_enable()=True 才会启动自动垃圾回收

    注意：
        一般情况下，不用重写__del__()方法，因为这个方法默认是要进行垃圾回收的，重写了之后就不会自动进行垃圾回收了；
        但是，非要重写的时候，在程序的最后调用一下父类的__del__()方法，进行垃圾回收
'''
import gc
import sys

class ClassA():
    def __init__(self):
        print('object born, id:%s'%self)

def f2():
    while True:
        c1 = ClassA() # 创建一个对象，将对象的引用赋值给变量c1
        c2 = ClassA() # 创建一个对象，将对象的引用赋值给变量c2
        c1.t = c2 # 添加一个属性t, 将c2的引用赋值给它
        c2.t = c1 # 添加一个属性t, 将c1的引用赋值给它
        del c1 # 删除c1引用
        del c2 # 删除c2引用

#gc.disable() # 关掉默认的垃圾回收机制
#gc.collect() # 显式执行垃圾回收
#f2()

# ---------------------------------------
y = gc.get_count()
x = gc.get_threshold()

print('当前自动执行垃圾回收的计数器：',y)
print('当前自动执行垃圾回收的频率：',x)

# 查看一个对象的引用个数
a = 'hello world!'
count = sys.getrefcount(a)
print('a 的引用个数是',count)